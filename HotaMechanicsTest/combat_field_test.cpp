#include "gtest/gtest.h"

#include "utils.h"
#include "../HotaMechanics/utils.h"
#include "../HotaMechanics/combat_field.h"

namespace CombatFieldTest {
	using namespace HotaMechanics;
	using namespace HotaMechanics::Utils;
	using namespace TestUtils;

	// CombatField::isHexWalkable()
	TEST(CombatField, shouldReturnTrueIfHexIsWalkableFalseOtherwise) {
		CombatField field(createField());

		EXPECT_FALSE(field.isHexWalkable(INVALID_HEX_ID)); // -1 is "no found" hex, so it cant be walkable

		field.fillHex(1, CombatHexOccupation::UNIT); // hex occupied by unit is not walkable
		EXPECT_FALSE(field.isHexWalkable(1));

		field.fillHex(2, CombatHexOccupation::SOFT_OBSTACLE); // hex occupied by soft obstacle (firewall, quicksand, etc, casted but not removable) is walkable
		EXPECT_TRUE(field.isHexWalkable(2));

		field.fillHex(3, CombatHexOccupation::SOLID_OBSTACLE); // hex occupied by solid obstacle (the one generated by game, but removable) is not walkable
		EXPECT_FALSE(field.isHexWalkable(3));

		field.fillHex(4, CombatHexOccupation::INDESTRUCTIBLE_OBSTACLE); // hex occupied by indestructible obstacle (force field/ the one generated by game) is not walkable
		EXPECT_FALSE(field.isHexWalkable(4));

		EXPECT_TRUE(field.isHexWalkable(5)); // empty hex is walkable

		EXPECT_FALSE(field.isHexWalkable(0)); // hex in first column of field is not walkable
		EXPECT_FALSE(field.isHexWalkable(34));

		EXPECT_FALSE(field.isHexWalkable(16)); // hex in last column of field is not walkable
		EXPECT_FALSE(field.isHexWalkable(50));
	}

	// CombatField::fillHex(id, occupation), CombatField::clearHex(id)
	TEST(CombatField, shouldClearAndFillHexSetCorrectOccupation) {
		CombatField field(createField());

		EXPECT_EQ(CombatHexOccupation::EMPTY, field.getById(32).getOccupation());
		field.fillHex(32, CombatHexOccupation::INDESTRUCTIBLE_OBSTACLE);
		EXPECT_EQ(CombatHexOccupation::INDESTRUCTIBLE_OBSTACLE, field.getById(32).getOccupation());

		field.clearHex(32);
		EXPECT_EQ(CombatHexOccupation::EMPTY, field.getById(32).getOccupation());
	}

	// CombatField::setTemplate(vector<int>)
	TEST(CombatField, shouldSetTemplateSetCorrectHexesOccupation) {
		CombatField field(createField());

		int empty_values = 0;
		for (int16_t hex : range(FIELD_SIZE))
			empty_values += field.getById(hex).getOccupation() == CombatHexOccupation::EMPTY;
		EXPECT_EQ(FIELD_SIZE, empty_values); // new field without template should have all empty hexes

		field = CombatField(createField(CombatFieldType::GRASS, CombatFieldTemplate::IMPS_2x100));

		empty_values = 0;
		for (int16_t hex : range(FIELD_SIZE))
			empty_values += field.getById(hex).getOccupation() == CombatHexOccupation::EMPTY;
		EXPECT_NE(FIELD_SIZE, empty_values); // setting custom template with obstacles should set some

		empty_values = 0;
		field.setTemplate(CombatFieldTemplate::EMPTY);
		for (int16_t hex : range(FIELD_SIZE))
			empty_values += field.getById(hex).getOccupation() == CombatHexOccupation::EMPTY;
		EXPECT_EQ(FIELD_SIZE, empty_values); // were changing field template back to empty
	}
};